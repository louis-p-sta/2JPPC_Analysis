# -*- coding: utf-8 -*-
"""
Created on Thu Jun 15 18:07:38 2023

@author: pwilson3
"""

import pandas as pd
from os import listdir, path
import sys
import matplotlib.pyplot as plt
import seaborn as sns
from cycler import cycler
import seaborn as sns
import numpy as np
from scipy.optimize import curve_fit
from scipy.interpolate import interp1d
import glob
import plot_PPC_IV_functions as plt_PPC
from scipy import constants as const

class PPC_data_collector:
    
    def __init__(self, script_type, data_dir, folderlist):
        """
        Collects measured PPC data from a collection of folders and sorts the 
        data into a dictionary.

        Parameters
        ----------
        script_type : one of the PPC measurement script types [LightIV, DarkIV, 
                                                               FixedCurrent,
                                                               FixedVoltage,
                                                               LightBias]
        data_dir : directory containing the subdirectories where the data is 
                   stored

        Returns
        -------
        A dictionary containing organized data from the specified script type.

        """
        self.dictionary = {}
        self.script_type = script_type

        for folder in folderlist:
            data_folder = path.join(data_dir, folder)
            if (script_type == 'FixedVoltage' and 
                len(glob.glob(path.join(data_folder, '*Beam_Block_Times*'))) > 0):
                times_file = glob.glob(path.join(data_folder, '*Beam_Block_Times*'))[0]
                times_df = pd.read_excel(times_file, header = 5)
                times_df = times_df.set_index('File Name')
            for file in listdir(data_folder):
                if file[-5:] == '.sciv':                                            # if the file is a OptiInstrument output file
                    if file.split('_')[3] in script_type:                           # set the specific script type to look for
                        self.script_type = script_type[0]
                        read_data = pd.read_table(path.join(data_folder, file))
                        read_data2 = read_data.set_index('%SUNLAB Data from OptiInstrument')
                        date = read_data2.loc['Date'].to_string().lstrip('     ')
                        name = read_data2.loc['Sample Name'].to_string().lstrip('     ')
                        if (script_type == 'FixedVoltage' and 
                            len(glob.glob(path.join(data_folder, '*Beam_Block_Times*'))) > 0):
                            # print(times_df)
                            block_time = times_df['Estimated Time to Open Block'][file]
                        else:
                            block_time = -1
                            
                        file_dict, file_info = self.construct_file_dict(read_data,
                                                                        read_data2,
                                                                        date, name,
                                                                        block_time = block_time) # reads the file info and stores it
                        self.construct_whole_dict(file_dict, file_info)       # organizes the file dictionaries into the full dictionary

#------------------------------------------------------------------------------
    def construct_whole_dict(self, file_dict, file_info):
        """
        Constructs the main dictionary from the smaller dictionaries 
        generated by each parsed file.

        Parameters
        ----------
        file_dict : the file dictionary produced for a specific file
        file_info : specific info from the file that will be used for 
                    nested dictionary keys

        Returns
        -------
        None.

        """
        # update the dictionary without overwriting previous entries
        if self.script_type == 'DarkIV':
            name, date = file_info
            if name in self.dictionary.keys():
                if date in self.dictionary[name].keys():                    # the date is not unique
                    suffix = 1
                    new_date_name = date + ' (' + str(suffix) +')'
                    while new_date_name in self.dictionary[name].keys():
                        suffix += 1
                        new_date_name = date + ' (' + str(suffix) +')'
                    file_dict[name][new_date_name] = file_dict[name][date]
                    del file_dict[name][date]
                    self.dictionary[name].update(file_dict[name])           # update the dictionary with the new name
            else:
                self.dictionary.update(file_dict)                           # the sample name is unique
        else:
            name, pos, filt, laser_curr = file_info
            if name in self.dictionary.keys():
                if pos in self.dictionary[name].keys():
                    if filt in self.dictionary[name][pos].keys():
                        if laser_curr in self.dictionary[name][pos][filt]: # measurement settings are not unique
                            suffix = 1
                            new_curr_name = laser_curr + ' (' + str(suffix) +')'
                            while new_curr_name in self.dictionary[name][pos][filt].keys():
                                suffix += 1
                                new_curr_name = laser_curr + ' (' + str(suffix) +')'
                            file_dict[name][pos][filt][new_curr_name] = file_dict[name][pos][filt][laser_curr]
                            del file_dict[name][pos][filt][laser_curr]
                            self.dictionary[name][pos][filt].update(file_dict[name][pos][filt]) # update the dictionary with the new name
                        else:
                            self.dictionary[name][pos][filt].update(file_dict[name][pos][filt]) # the laser current is unique
                    else:
                        self.dictionary[name][pos].update(file_dict[name][pos])                 # the filter is unique
                else:
                    self.dictionary[name].update(file_dict[name])           # the lens position is unique
            else:
                self.dictionary.update(file_dict)                           # the sample name is unique


#------------------------------------------------------------------------------
    def construct_file_dict(self, read_data, read_data2, date, name, block_time = -1):
        """
        

        Parameters
        ----------
        read_data : Dataframe containing file data
        read_data2 : Dataframe containing file data (they're indexed 
                                                     differently)
        date : Date the measurement was taken (dictionary key)
        name : Name of the sample (dictionary key)

        Returns
        -------
        file_dict : The file dictionary produced for a specific file
        file_info : Specific info from the file that will be used for 
                    nested dictionary keys.

        """
        file_dict = {} # initiate an empty dictionary
        if self.script_type == 'DarkIV':
            file_dict.update({name: {
                'Date': date}})
            file_info = [name, date]
            
            new_header = read_data.iloc[9]
            read_data3 = read_data.iloc[10:]
            read_data3.columns = new_header
            voltage = read_data3['Voltage (V)'].astype(float).to_numpy()
            current = read_data3['Current (A)'].astype(float).to_numpy()
            if voltage[0] < voltage[-1]:
                direction = "Forward"
            else:
                direction = "Reverse"

            # put all the file parameters in a dictionary
            file_dict.update({name: {
                'Date': date,
                'Voltage (V)': voltage,
                'Current (A)': current}})
        else:
            pos = read_data2.loc['Lens Position'].to_string()
            pos = pos.lstrip('     ')
            
            filt = read_data2.loc['Filter'].to_string()
            filt = filt.replace('ND2 and ND1', 'ND1 + ND2')
            filt = filt.replace('None', 'No Filter')
            filt = filt.replace('NoFilter', 'No Filter')
            filt = filt.replace('ND2 + ND1', 'ND1 + ND2')
            filt = filt.replace('ND1+ND2', 'ND1 + ND2')
            filt = filt.replace('ND2+ND1', 'ND1 + ND2')
            filt = filt.lstrip('     ')
            
            dur = float(read_data2.loc['Duration (s)'])
            try:
                laser_curr = read_data2.loc['Laser Current(A)']
                laser_curr = laser_curr.to_string()
                laser_curr = laser_curr.lstrip('     ')
            except KeyError:
                laser_curr = read_data2.loc['Laser Current (A)']
            # print(laser_curr, type(laser_curr))
            if float(laser_curr) > 1000:
                laser_curr = float(laser_curr)/1000 # if the current is in mA change it to A
                laser_curr = str(laser_curr)
            laser_wavl = read_data2.loc['Laser Wavelenth'].to_string()
            laser_wavl = laser_wavl.lstrip('     ')
            file_info = [name, pos, filt, laser_curr]
            
            if self.script_type == 'LightIV':
                Isc = float(read_data2.loc['Isc (A)'])
                Voc = float(read_data2.loc['Voc (V)'])
                Pmax = float(read_data2.loc['Pmax (I)']) 
                Imp = float(read_data2.loc['Imp (A)'])
                Vmp = float(read_data2.loc['Vmp (V)'])
                FF = float(read_data2.loc['FF'])
                
                new_header = read_data.iloc[21]
                read_data3 = read_data.iloc[22:]
                read_data3.columns = new_header
                voltage = read_data3['Voltage (V)'].astype(float).to_numpy()
                current = read_data3['Current (A)'].astype(float).to_numpy()
                if voltage[0] < voltage[-1]:
                    direction = "Forward"
                else:
                    direction = "Reverse"

                # put all the file parameters in a dictionary
                file_dict.update({name: {
                    pos: {
                        filt:{
                            laser_curr: {
                                'Date': date,
                                'Duration (s)': dur,
                                'Direction': direction,
                                'Laser Wavelength': laser_wavl,
                                'Isc (A)': Isc,
                                'Voc (V)': Voc,
                                'Pmax (I)': Pmax,
                                'Imp (A)': Imp,
                                'Vmp (V)': Vmp,
                                'FF': FF,
                                'Voltage (V)': voltage,
                                'Current (A)': current}}}}})

            elif self.script_type == 'LightBias':
                # print(self.script_type)
                laserB_wavl = read_data2.loc['LB Laser Wavelength'].to_string()
                laserB_wavl = laserB_wavl.lstrip('     ')
                laserB_lasr_curr = read_data2.loc['LB Laser Current (A)'].to_string()
                laserB_lasr_curr = laserB_lasr_curr.lstrip('     ')
                
                Isc = float(read_data2.loc['Isc (A)'])
                Voc = float(read_data2.loc['Voc (V)'])
                Pmax = float(read_data2.loc['Pmax (I)']) 
                Imp = float(read_data2.loc['Imp (A)'])
                Vmp = float(read_data2.loc['Vmp (V)'])
                FF = float(read_data2.loc['FF'])

                new_header = read_data.iloc[23]
                read_data3 = read_data.iloc[24:]
                read_data3.columns = new_header
                voltage = read_data3['Voltage (V)'].astype(float).to_numpy()
                current = read_data3['Current (A)'].astype(float).to_numpy()
                if voltage[0] < voltage[-1]:
                    direction = "Forward"
                else:
                    direction = "Reverse"

                # put all the file parameters in a dictionary
                file_dict.update({name: {
                    pos: {
                        filt:{
                            laser_curr: {
                                'Date': date,
                                'Duration (s)': dur,
                                'Direction': direction,
                                'Laser Wavelength': laser_wavl,
                                'Laser B Wavelength': laserB_wavl,
                                'Laser B Current (A)': laserB_lasr_curr,
                                'Isc (A)': Isc,
                                'Voc (V)': Voc,
                                'Pmax (I)': Pmax,
                                'Imp (A)': Imp,
                                'Vmp (V)': Vmp,
                                'FF': FF,
                                'Voltage (V)': voltage,
                                'Current (A)': current}}}}})
                
            elif self.script_type == 'FixedCurrent':
                fixed_curr = read_data2.loc['Fixed Current (A)'].to_string()
                fixed_curr = fixed_curr.lstrip('     ')
                
                new_header = read_data.iloc[15]
                read_data3 = read_data.iloc[16:]
                read_data3.columns = new_header
                time = read_data3['Time (s)'].astype(float).to_numpy()
                voltage = read_data3['Voltage (V)'].astype(float).to_numpy()
                
                # put all the file parameters in a dictionary
                file_dict.update({name: {
                    pos: {
                        filt:{
                            laser_curr: {
                                'Date': date,
                                'Laser Wavelength': laser_wavl,
                                'Duration (s)': dur,
                                'Fixed Current (A)': fixed_curr,
                                'Time (s)': time,
                                'Voltage (V)': voltage}}}}})
                
            elif self.script_type == 'FixedVoltage':
                fixed_volt = read_data2.loc['Fixed Voltage (V)'].to_string()
                fixed_volt = fixed_volt.lstrip('     ')
        
                new_header = read_data.iloc[15]
                read_data3 = read_data.iloc[16:]
                read_data3.columns = new_header
                time = read_data3['Time (s)'].astype(float).to_numpy()
                current = read_data3['Current (I)'].astype(float).to_numpy()
                if block_time > 0:
                    index = (np.abs(time - block_time)).argmin() # get the index closest to the approximate time given from the supplied file
                    t_blocked = time[index] # grab the exact measured point
                    Isc_at_zero = current[index]
                else:
                    index = 'N/A'
                    t_blocked = 'N/A'
                    Isc_at_zero = 'N/A'
                # put all the file parameters in a dictionary
                file_dict.update({name: {
                    pos: {
                        filt:{
                            laser_curr: {
                                'Date': date,
                                'Laser Wavelength': laser_wavl,
                                'Duration (s)': dur,
                                'Fixed Voltage (V)': fixed_volt,
                                'Time (s)': time,
                                'Current (A)': current,
                                'Time Blocked (s)': t_blocked,
                                'Unblocked Index': index,
                                'Isc_at_zero': Isc_at_zero}}}}})
        return file_dict, file_info

#------------------------------------------------------------------------------
    def get_powers(self, table, alternate_table = [], filters = 'all', LaserWL = '1550nm', 
                   calibrations = False, keyND1ND2 = 'Average Power ND1 + ND2',
                   keyND1 = 'Average Power ND1', keyND2 = 'Average Power ND2',
                   keyNoFilter = 'Average Power No Filter',
                   keyUncertainty = 'Error on Highlighted'):
        """
        Updates the dictionary with laser powers as measured from a thermopile
    
        Parameters
        ----------
        table : power table generated from the excel file
        alternate_table : temperature tuned powers
            DESCRIPTION. The default is [].
        filters: 'all', 'ND1', 'ND2', 'ND1 + ND2', or 'No Filter'. Depending on 
                 the format of the input files 
    
        Returns
        -------
        None.
    
        """
        ### DEPRECATED ### Still working out how to handle files with different column names
        # for name in self.dictionary.keys():
        #     for pos in self.dictionary[name].keys():
        #         for filt in self.dictionary[name][pos].keys():
        #             for curr in self.dictionary[name][pos][filt].keys():
        #                 if filt == 'ND1 + ND2':
        #                     self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['No Filter']*table.loc[float(curr.split('(')[0])]['ND2/NoFilter']*table.loc[float(curr.split('(')[0])]['ND1/NoFilter']})
        #                     if np.size(alternate_table) != 0:
        #                         self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Average Power No Filter']*table.loc[float(curr.split('(')[0])]['ND2/NoFilter']*table.loc[float(curr.split('(')[0])]['ND1/NoFilter']})
        #                 elif filt == 'ND2':
        #                     self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['ND2']})
        #                     if np.size(alternate_table) != 0:
        #                         self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Average Power No Filter']*table.loc[float(curr.split('(')[0])]['ND2/NoFilter']})
        #                 elif filt == 'ND1':
        #                     self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['ND1']})
        #                     if np.size(alternate_table) != 0:
        #                         self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Average Power No Filter']*table.loc[float(curr.split('(')[0])]['ND1/NoFilter']})
        #                 elif filt == 'No Filter':
        #                     self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['No Filter']})
        #                     if np.size(alternate_table) != 0:
        #                         self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Average Power No Filter']})
        #                 else:
        #                     print('Unknown power at: ', name, pos, filt, curr)
                            
        for name in self.dictionary.keys():
            for pos in self.dictionary[name].keys():
                for filt in self.dictionary[name][pos].keys():
                    for curr in self.dictionary[name][pos][filt].keys():
                        if calibrations == True:
                            if (LaserWL == '1550nm' and self.dictionary[name][pos][filt][curr]['Laser Wavelength'] == '1550nm'):
                                if filt == 'ND1 + ND2' and (filters == 'all' or filters == 'ND1 + ND2'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['No Filter']*table.loc[float(curr.split('(')[0])]['ND2/NoFilter']*table.loc[float(curr.split('(')[0])]['ND1/NoFilter']})
                                    if np.size(alternate_table) != 0:
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['ND1+ND2']})
                                elif filt == 'ND2' and (filters == 'all' or filters == 'ND2'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['ND2']})
                                    if np.size(alternate_table) != 0:
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['ND2']})
                                elif filt == 'ND1' and (filters == 'all' or filters == 'ND1'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['ND1']})
                                    if np.size(alternate_table) != 0:
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['ND1']})
                                elif filt == 'No Filter' and (filters == 'all' or filters == 'No Filter'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['No Filter']})
                                    if np.size(alternate_table) != 0:
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Power No Filter (W)']})
                                else:
                                    pass
                                    # print('Unknown power at: ', name, pos, filt, curr)
                        else:
                            if (LaserWL == '1550nm' and self.dictionary[name][pos][filt][curr]['Laser Wavelength'] == '1550nm'):
                                if filt == 'ND1 + ND2' and (filters == 'all' or filters == 'ND1 + ND2'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['No Filter']*table.loc[float(curr.split('(')[0])]['ND2/NoFilter']*table.loc[float(curr.split('(')[0])]['ND1/NoFilter']})
                                    if np.size(alternate_table) != 0:
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Average Power ND1 + ND2']})
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) Error (W)': alternate_table.loc[float(curr.split('(')[0])]['Error on Highlighted']})
                                elif filt == 'ND2' and (filters == 'all' or filters == 'ND2'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['ND2']})
                                    if np.size(alternate_table) != 0:
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Average Power ND2']})
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) Error (W)': alternate_table.loc[float(curr.split('(')[0])]['Error on Highlighted']})
                                elif filt == 'ND1' and (filters == 'all' or filters == 'ND1'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['ND1']})
                                    if np.size(alternate_table) != 0:
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Average Power ND1']})
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) Error (W)': alternate_table.loc[float(curr.split('(')[0])]['Error on Highlighted']})
                                elif filt == 'No Filter' and (filters == 'all' or filters == 'No Filter'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (W)': table.loc[float(curr.split('(')[0])]['No Filter']})
                                    if np.size(alternate_table) != 0:
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': alternate_table.loc[float(curr.split('(')[0])]['Average Power No Filter']})
                                        self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) Error (W)': alternate_table.loc[float(curr.split('(')[0])]['Error on Highlighted']})
                                else:
                                    pass
                                    # print('Unknown power at: ', name, pos, filt, curr)
                            elif (LaserWL == '1310nm' and self.dictionary[name][pos][filt][curr]['Laser Wavelength'] == '1310nm'):
                                try:
                                    self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': table.loc[float(curr.split('(')[0])]['Power No Filter (W)']})
                                except KeyError as err:
                                    print('KeyError in get_powers(): ', err, ' sample: ', name)
                                    self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': -1})
                                    
                            elif (LaserWL == '1310nm+1550nm'):
                                LaserB_wl = float(self.dictionary[name][pos][filt][curr]['Laser B Current (A)'])
                                if filt == 'ND1 + ND2' and (filters == 'all' or filters == 'ND1 + ND2'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': table.loc[float(curr.split('(')[0])]['Average Power ND1 + ND2'] + alternate_table.loc[LaserB_wl]['Power No Filter (W)']})
                                elif filt == 'ND2' and (filters == 'all' or filters == 'ND2'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': table.loc[float(curr.split('(')[0])]['Average Power ND2'] + alternate_table.loc[LaserB_wl]['Power No Filter (W)']})
                                elif filt == 'ND1' and (filters == 'all' or filters == 'ND1'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': table.loc[float(curr.split('(')[0])]['Average Power ND1'] + alternate_table.loc[LaserB_wl]['Power No Filter (W)']})
                                elif filt == 'No Filter' and (filters == 'all' or filters == 'No Filter'):
                                    self.dictionary[name][pos][filt][curr].update({'Power (LTT tuned) (W)': table.loc[float(curr.split('(')[0])]['Average Power No Filter'] + alternate_table.loc[LaserB_wl]['Power No Filter (W)']})
                                else:
                                    pass

#------------------------------------------------------------------------------
    def get_powers_updated(self, table, alternate_table = [], filters = 'all', 
                           LaserWL = '1550nm', calibrations = False, 
                           keyND1ND2 = 'Average Power ND1 + ND2', 
                           keyND1 = 'Average Power ND1', 
                           keyND2 = 'Average Power ND2', 
                           keyNoFilter = 'Average Power No Filter',
                           keyNoFilter1310 = 'Average Power No Filter',
                           keyUncertainty = 'Error on Highlighted',
                           alternate_label = 'Power (LTT tuned) (W)',
                           AlternatekeyUncertainty = 'Error on Highlighted'):
    
        for name in self.dictionary.keys():
            for pos in self.dictionary[name].keys():
                for filt in self.dictionary[name][pos].keys():
                    for curr in self.dictionary[name][pos][filt].keys():
                        if (LaserWL == '1550nm' and self.dictionary[name][pos][filt][curr]['Laser Wavelength'] == '1550nm'):
                            if filt == 'ND1 + ND2' and (filters == 'all' or filters == 'ND1 + ND2'):
                                power = table.loc[float(curr.split('(')[0])][keyND1ND2]
                                power_err = table.loc[float(curr.split('(')[0])][keyUncertainty]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power})
                                self.dictionary[name][pos][filt][curr].update({'Power Error (W)': power_err})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1520e-9))})
                                if np.size(alternate_table) != 0:
                                    power = alternate_table.loc[float(curr.split('(')[0])][keyND1ND2]
                                    power_err = alternate_table.loc[float(curr.split('(')[0])][AlternatekeyUncertainty]
                                    self.dictionary[name][pos][filt][curr].update({alternate_label: power})
                                    self.dictionary[name][pos][filt][curr].update({'Alternate Power Error (W)': power_err})
                                    self.dictionary[name][pos][filt][curr].update({'Alternate Photon Flux': power/(const.h*const.c/(1520e-9))})
                            elif filt == 'ND2' and (filters == 'all' or filters == 'ND2'):
                                power = table.loc[float(curr.split('(')[0])][keyND2]
                                power_err = table.loc[float(curr.split('(')[0])][keyUncertainty]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power})
                                self.dictionary[name][pos][filt][curr].update({'Power Error (W)': power_err})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1520e-9))})
                                if np.size(alternate_table) != 0:
                                    power = alternate_table.loc[float(curr.split('(')[0])][keyND2]
                                    power_err = alternate_table.loc[float(curr.split('(')[0])][AlternatekeyUncertainty]
                                    self.dictionary[name][pos][filt][curr].update({alternate_label: power})
                                    self.dictionary[name][pos][filt][curr].update({'Alternate Power Error (W)': power_err})
                                    self.dictionary[name][pos][filt][curr].update({'Alternate Photon Flux': power/(const.h*const.c/(1520e-9))})
                            elif filt == 'ND1' and (filters == 'all' or filters == 'ND1'):
                                power = table.loc[float(curr.split('(')[0])][keyND1]
                                power_err = table.loc[float(curr.split('(')[0])][keyUncertainty]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power})
                                self.dictionary[name][pos][filt][curr].update({'Power Error (W)': power_err})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1520e-9))})
                                if np.size(alternate_table) != 0:
                                    power = alternate_table.loc[float(curr.split('(')[0])][keyND1]
                                    power_err = alternate_table.loc[float(curr.split('(')[0])][AlternatekeyUncertainty]
                                    self.dictionary[name][pos][filt][curr].update({alternate_label: power})
                                    self.dictionary[name][pos][filt][curr].update({'Alternate Power Error (W)': power_err})
                                    self.dictionary[name][pos][filt][curr].update({'Alternate Photon Flux': power/(const.h*const.c/(1520e-9))})
                            elif filt == 'No Filter' and (filters == 'all' or filters == 'No Filter'):
                                power = table.loc[float(curr.split('(')[0])][keyNoFilter]
                                power_err = table.loc[float(curr.split('(')[0])][keyUncertainty]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power})
                                self.dictionary[name][pos][filt][curr].update({'Power Error (W)': power_err})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1520e-9))})
                                if np.size(alternate_table) != 0:
                                    power = alternate_table.loc[float(curr.split('(')[0])][keyNoFilter]
                                    power_err = alternate_table.loc[float(curr.split('(')[0])][AlternatekeyUncertainty]
                                    self.dictionary[name][pos][filt][curr].update({alternate_label: power})
                                    self.dictionary[name][pos][filt][curr].update({'Alternate Power Error (W)': power_err})
                                    self.dictionary[name][pos][filt][curr].update({'Alternate Photon Flux': power/(const.h*const.c/(1520e-9))})
                            else:
                                pass
    
                        elif (LaserWL == '1310nm' and self.dictionary[name][pos][filt][curr]['Laser Wavelength'] == '1310nm'):
                            try:
                                power = table.loc[float(curr.split('(')[0])][keyNoFilter1310]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1310e-9))})
                            except KeyError as err:
                                print('KeyError in get_powers(): ', err, ' sample: ', name)
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': -1})
    
                        elif (LaserWL == '1310nm+1550nm'):
                            LaserB_wl = float(self.dictionary[name][pos][filt][curr]['Laser B Current (A)'])
                            if filt == 'ND1 + ND2' and (filters == 'all' or filters == 'ND1 + ND2'):
                                power = table.loc[float(curr.split('(')[0])][keyND1ND2]
                                power2 = alternate_table.loc[LaserB_wl][keyNoFilter1310]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power + power2})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1520e-9)) + power/(const.h*const.c/(1310e-9))})
                            elif filt == 'ND2' and (filters == 'all' or filters == 'ND2'):
                                power = table.loc[float(curr.split('(')[0])][keyND2]
                                power2 = alternate_table.loc[LaserB_wl][keyNoFilter1310]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power + power2})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1520e-9)) + power/(const.h*const.c/(1310e-9))})
                            elif filt == 'ND1' and (filters == 'all' or filters == 'ND1'):
                                power = table.loc[float(curr.split('(')[0])][keyND1]
                                power2 = alternate_table.loc[LaserB_wl][keyNoFilter1310]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power + power2})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1520e-9)) + power/(const.h*const.c/(1310e-9))})
                            elif filt == 'No Filter' and (filters == 'all' or filters == 'No Filter'):
                                power = table.loc[float(curr.split('(')[0])][keyNoFilter]
                                power2 = alternate_table.loc[LaserB_wl][keyNoFilter1310]
                                self.dictionary[name][pos][filt][curr].update({'Power (W)': power + power2})
                                self.dictionary[name][pos][filt][curr].update({'Photon Flux': power/(const.h*const.c/(1520e-9)) + power/(const.h*const.c/(1310e-9))})
                            else:
                                pass

#------------------------------------------------------------------------------
    def add_to_dict(self, items, power_label = 'Power (W)', calibration_function = None,
                    Atot = 0.054, alternate_power_label = 'Power (LTT tuned) (W)'):
        """
        Updates the dictionary with efficiency, spectral resonse, and device 
        power curves. Or with power calibration ratio, calibrated efficiency, 
        and calibrated spectral response.

        Parameters
        ----------
        items : one of initial, calibration 1, fit_Isc, fit_Pmax, fit_Voc_slope
        power_label : Power values used for Pin. Either 'Power (W)' or 
                     'Power LTT (W)'
            DESCRIPTION. The default is 'Power (W)'.

        Returns
        -------
        None.

        """
        if (self.script_type == 'DarkIV' or self.script_type == 'FixedCurrent'
            or self.script_type == 'FixedVoltage'):
            print('script_type is not compatible with add_to_dict')
        else:
            for name in self.dictionary.keys():
                for pos in self.dictionary[name].keys():
                    for filt in self.dictionary[name][pos].keys():
                        for curr in self.dictionary[name][pos][filt].keys():
                            if items == 'initial':
                                try:
                                    self.dictionary[name][pos][filt][curr].update({'Eff': self.dictionary[name][pos][filt][curr]['Pmax (I)']*100/self.dictionary[name][pos][filt][curr][power_label]})
                                    self.dictionary[name][pos][filt][curr].update({'SR (A/W)': self.dictionary[name][pos][filt][curr]['Isc (A)']/self.dictionary[name][pos][filt][curr][power_label]})
                                    self.dictionary[name][pos][filt][curr].update({'P_out (W)': self.dictionary[name][pos][filt][curr]['Voltage (V)']*self.dictionary[name][pos][filt][curr]['Current (A)']})
                                except KeyError as err:
                                    print('Key Error in add_to_dict: ', err)
                                    print(name, pos, filt, curr)
                                if alternate_power_label in self.dictionary[name][pos][filt][curr]:
                                    try:
                                        self.dictionary[name][pos][filt][curr].update({'Eff (alt)': self.dictionary[name][pos][filt][curr]['Pmax (I)']*100/self.dictionary[name][pos][filt][curr][alternate_power_label]})
                                        self.dictionary[name][pos][filt][curr].update({'SR (A/W) (alt)': self.dictionary[name][pos][filt][curr]['Isc (A)']/self.dictionary[name][pos][filt][curr][alternate_power_label]})
                                    except KeyError as err:
                                        print('Key Error in add_to_dict: ', err)
                                        print(name, pos, filt, curr)
                            elif items == 'calibration 1':
                                if calibration_function == None:
                                    print('Must input a function that assigns the calibrated powers.')
                                else:
                                    try:
                                        self.dictionary[name][pos][filt][curr].update({'Power Calibration 1 (W)': calibration_function(self.dictionary[name][pos][filt][curr][power_label])})
                                        self.dictionary[name][pos][filt][curr].update({'Pcal1/Pin': self.dictionary[name][pos][filt][curr]['Power Calibration 1 (W)']/self.dictionary[name][pos][filt][curr][power_label]})
                                        self.dictionary[name][pos][filt][curr].update({'Eff Calibration 1': self.dictionary[name][pos][filt][curr]['Pmax (I)']*100/self.dictionary[name][pos][filt][curr]['Power Calibration 1 (W)']})
                                        self.dictionary[name][pos][filt][curr].update({'SR Calibration 1 (A/W)': self.dictionary[name][pos][filt][curr]['Isc (A)']/self.dictionary[name][pos][filt][curr]['Power Calibration 1 (W)']})
                                    except KeyError as err:
                                        print('KeyError in Calibration 1 of add_to_dict:', err)
                                        print(name, pos, filt, curr)
                            elif items == 'calibration 1 error':
                                if calibration_function == None:
                                    print('Must input a function that assigns the calibrated powers.')
                                else:
                                    try:
                                        self.dictionary[name][pos][filt][curr].update({'Power Calibration 1 err (W)': calibration_function(self.dictionary[name][pos][filt][curr][power_label])})
                                        # self.dictionary[name][pos][filt][curr].update({'Pcal1/Pin': self.dictionary[name][pos][filt][curr]['Power Calibration 1 (W)']/self.dictionary[name][pos][filt][curr][power_label]})
                                        try:
                                            v = self.dictionary[name][pos][filt][curr]['Vmp_uncertainty']/self.dictionary[name][pos][filt][curr]['Vmp (V)']
                                            i = self.dictionary[name][pos][filt][curr]['Imp_uncertainty']/self.dictionary[name][pos][filt][curr]['Imp (A)']
                                            p = self.dictionary[name][pos][filt][curr]['Power Calibration 1 err (W)']/self.dictionary[name][pos][filt][curr]['Power Calibration 1 (W)']
                                            eff_err = self.dictionary[name][pos][filt][curr]['Eff Calibration 1']*np.sqrt(v**2 + i**2 + p**2)
                                            self.dictionary[name][pos][filt][curr].update({'Eff Calibration 1 err': eff_err})
                                        except ZeroDivisionError as err:
                                            print(err,': Setting va;ie')
                                            print(name, pos, filt, curr)
                                            self.dictionary[name][pos][filt][curr].update({'Eff Calibration 1 err': 'N/A'})
                                        # self.dictionary[name][pos][filt][curr].update({'SR Calibration 1 (A/W)': self.dictionary[name][pos][filt][curr]['Isc (A)']/self.dictionary[name][pos][filt][curr]['Power Calibration 1 (W)']})
                                    except KeyError as err:
                                        print('KeyError in Calibration 1 of add_to_dict:', err)
                                        print(name, pos, filt, curr)
                            elif items == 'fit_Isc':
                                try:
                                    # fit to Isc
                                    fits = plt_PPC.fit_Isc(self.dictionary, name, [pos], [filt], [curr], 
                                                    'Voltage (V)', 'Current (A)')
                                    self.dictionary[name][pos][filt][curr].update({'Isc_fit (A)': fits[0]})
                                    self.dictionary[name][pos][filt][curr].update({'Vzero_fit (V)': fits[1]})
                                    self.dictionary[name][pos][filt][curr].update({'Isc_fit_Vpoints': fits[2]})
                                    self.dictionary[name][pos][filt][curr].update({'Isc_fit_Ipoints': fits[3]})
                                    
                                except KeyError as err:
                                    print(err)
                                    print(name, pos, filt, curr)
                            
                            elif items == 'fit_Pmax':
                                    # fit to Pmax
                                try:
                                    fits = plt_PPC.fit_Pmax(self.dictionary, name, [pos], [filt], [curr], 
                                                    'Voltage (V)', 'P_out (W)')
                                    self.dictionary[name][pos][filt][curr].update({'Pmax_fit (W)': -fits[0]})
                                    self.dictionary[name][pos][filt][curr].update({'Vmp_fit (V)': fits[1]})
                                    self.dictionary[name][pos][filt][curr].update({'Imp_fit (A)': fits[0]/fits[1]})
                                    self.dictionary[name][pos][filt][curr].update({'Pmax_fit_Vpoints': fits[2]})
                                    self.dictionary[name][pos][filt][curr].update({'Pmax_fit_Ppoints': fits[3]})
                                    
                                    # Pmax fit to adjust Efficiency
                                    self.dictionary[name][pos][filt][curr].update({'Eff_Pmax_fit': self.dictionary[name][pos][filt][curr]['Pmax_fit (W)']*100/self.dictionary[name][pos][filt][curr][power_label]})
                                    
                                    # Pmax to adjust spectral response
                                    self.dictionary[name][pos][filt][curr].update({'SR_Isc_fit (A/W)': self.dictionary[name][pos][filt][curr]['Isc_fit (A)']/self.dictionary[name][pos][filt][curr][power_label]})
                                    
                                except KeyError as err:
                                    print(err)
                                    print(name, pos, filt, curr)
                            
                            elif items == 'fit_Voc_slope':
                                try:
                                    # fit the slope of the IV curve at Voc
                                    fits = plt_PPC.fit_Voc_slope(self.dictionary, name, [pos], [filt], [curr],
                                                                 'Voltage (V)', 'Current (A)', yfactor = 1/Atot)
                                    self.dictionary[name][pos][filt][curr].update({'Slope_at_Voc(m)': fits[0]}) # (m, b) as y = m*x + b
                                    self.dictionary[name][pos][filt][curr].update({'Slope_at_Voc(b)': fits[1]}) # (m, b) as y = m*x + b
                                    self.dictionary[name][pos][filt][curr].update({'Inverse_slope_at_Voc(1/m)': 1/fits[0]})
                                except KeyError as err:
                                    print('KeyError in Calibration 1 of add_to_dict:', err)
                                    print(name, pos, filt, curr)
                            elif items == 'fit_Jsc_slope':
                                try:
                                    # fit the slope of the IV curve at Voc
                                    fits = plt_PPC.fit_Jsc_slope(self.dictionary, name, [pos], [filt], [curr],
                                                                 'Voltage (V)', 'Current (A)', yfactor = 1/Atot)
                                    self.dictionary[name][pos][filt][curr].update({'Slope_at_Jsc(m)': fits[0]}) # (m, b) as y = m*x + b
                                    self.dictionary[name][pos][filt][curr].update({'Slope_at_Jsc(b)': fits[1]}) # (m, b) as y = m*x + b
                                    self.dictionary[name][pos][filt][curr].update({'Inverse_slope_at_Jsc(1/m)': 1/fits[0]})
                                except KeyError as err:
                                   print('KeyError in Calibration 1 of add_to_dict:', err)
                                   print(name, pos, filt, curr)
                            elif items == 'Isc_uncertainty':
                                try:
                                    if abs(self.dictionary[name][pos][filt][curr]['Isc (A)']) < 0.01:
                                        error = abs(self.dictionary[name][pos][filt][curr]['Isc (A)'])*0.00035 + 5.6e-6
                                        self.dictionary[name][pos][filt][curr].update({'Isc_uncertainty': error})
                                    elif ((0.01 <= abs(self.dictionary[name][pos][filt][curr]['Isc (A)']) and abs(self.dictionary[name][pos][filt][curr]['Isc (A)']) < 0.1)):
                                        error = abs(self.dictionary[name][pos][filt][curr]['Isc (A)'])*0.00055 + 56e-6
                                        self.dictionary[name][pos][filt][curr].update({'Isc_uncertainty': error})
                                    else:
                                        error = abs(self.dictionary[name][pos][filt][curr]['Isc (A)'])*0.00066 + 1.57e-3
                                        self.dictionary[name][pos][filt][curr].update({'Isc_uncertainty': error})
                                except KeyError as err:
                                    pass
                                    print('KeyError in Isc Uncertainty of add_to_dict:', err)
                                    print(name, pos, filt, curr)
                            elif items == 'Imp_uncertainty':
                                try:
                                    if abs(self.dictionary[name][pos][filt][curr]['Imp (A)']) < 0.01:
                                        error = abs(self.dictionary[name][pos][filt][curr]['Imp (A)'])*0.00035 + 5.6e-6
                                        self.dictionary[name][pos][filt][curr].update({'Imp_uncertainty': error})
                                    elif ((0.01 <= abs(self.dictionary[name][pos][filt][curr]['Imp (A)']) and abs(self.dictionary[name][pos][filt][curr]['Imp (A)']) < 0.1)):
                                        error = abs(self.dictionary[name][pos][filt][curr]['Imp (A)'])*0.00055 + 56e-6
                                        self.dictionary[name][pos][filt][curr].update({'Imp_uncertainty': error})
                                    else:
                                        error = abs(self.dictionary[name][pos][filt][curr]['Imp (A)'])*0.00066 + 1.57e-3
                                        self.dictionary[name][pos][filt][curr].update({'Imp_uncertainty': error})
                                except KeyError as err:
                                    pass
                                    print('KeyError in Imp Uncertainty of add_to_dict:', err)
                                    print(name, pos, filt, curr)
                            elif items == 'Vmp_uncertainty':
                                try:
                                    error = abs(self.dictionary[name][pos][filt][curr]['Vmp (V)'])*0.00012 + 1.3e-3
                                    self.dictionary[name][pos][filt][curr].update({'Vmp_uncertainty': error})
                                except KeyError as err:
                                    pass
                                    print('KeyError in Vmp Uncertainty of add_to_dict:', err)
                                    print(name, pos, filt, curr)
                            else:
                                print('Method in "items" not recognized. Options are: initial, calibration 1, fit_Isc, fit_Pmax, fit_Voc_slope')

